#!/usr/bin/env ruby

require "booru"

require "json"
require "thor"

# admin explore maintenance

# comments
Resources = %w(
  advertisements
  api_keys
  artist_commentaries
  artist_commentary_versions
  artist_versions
  artists
  bans
  bulk_update_requests
  counts
  delayed_jobs
  dmails
  dtext_preview
  favorite_groups
  favorites
  forum_posts
  forum_topics
  ip_bans
  iqdb_queries
  janitor_trials
  meta_searches
  mod_actions
  news_updates
  note_previews
  note_versions
  notes
  pool_element
  pool_versions
  pools
  post_appeals
  post_flags
  post_versions
  posts
  related_tag
  reports
  saved_search_category_change
  saved_searches
  session
  source
  static
  super_voters
  tag_alias_request
  tag_aliases
  tag_implication_request
  tag_implications
  tag_subscriptions
  tags
  uploads
  user_feedbacks
  user_name_change_requests
  user_revert
  user_upgrade
  users
  wiki_page_versions
  wiki_pages
)

Resources.each do |name|
  name = name.capitalize

  klass = Class.new(Thor) do
    define_singleton_method(:name) { name.downcase }

    option :from,   aliases: "-f", desc: "start listing from id N",             type: :numeric,  default: 0
    option :to,     aliases: "-t", desc: "stop listing at id N",                type: :numeric, default: 100_000_000
    option :limit,  aliases: "-l", desc: "limit N results per request",         type: :numeric,  default: 1000
    option :follow, aliases: "-F", desc: "continuously print incoming records", type: :boolean,  default: false
    desc "index", "list #{name}"
    def index(*ids)
      if ids.empty?
        resource.each(from: options[:from], to: options[:to], limit: options[:limit]) do |record|
          format record
        end
      else
        show ids
      end
    end

    desc "show ID...", "show #{name}(s) with ID(s)"
    def show(*ids)
      code = 0

      json = ids.map do |id|
        record, error = resource.show(id)

        if error
          code = 1
          warn error.to_s
        end

        record
      end

      format json
      exit code
    end

    default_command :index

    no_commands do
      def format(*args)
        if options[:pretty]
          puts JSON.pretty_generate(*args) 
        else
          puts JSON.generate(*args)
        end
      end

      def booru
        @booru ||= Booru.new(
          options[:site],
          login: options[:login],
          api_key: options[:api_key],
          ssl: options[:ssl]
        )
      end

      def resource
        @resource ||= booru.send(self.class.name.downcase)
      end
    end
  end

  Object.const_set(name, klass)
end

class CLI < Thor
  class_option :site,    aliases: "-s", desc: "the site to use",          type: :string,  default: ENV["BOORU_SITE"] || "danbooru.donmai.us"
  class_option :ssl,     aliases: "-S", desc: "connect with SSL",         type: :boolean, default: ENV["BOORU_SSL"] || false
  class_option :login,   aliases: "-L", desc: "the username to use",      type: :string,  default: ENV["BOORU_LOGIN"]
  class_option :api_key, aliases: "-K", desc: "the API key to use",       type: :string,  default: ENV["BOORU_API_KEY"]
  class_option :pretty,  aliases: "-p", desc: "pretty print JSON output", type: :boolean, default: ENV["BOORU_PRETTY"] || false

  Resources.each do |cmd|
    desc "#{cmd} SUBCOMMAND ...ARGS", "/#{cmd}"
    subcommand cmd, const_get(cmd.capitalize)
  end
end

CLI.start(ARGV)
